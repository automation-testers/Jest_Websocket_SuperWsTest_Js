"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AllureReporter = exports.dateStrShort = exports.dateStr = void 0;
const allure_js_commons_1 = require("allure-js-commons");
const path_1 = require("path");
const stripAnsi = require('strip-ansi');
var SpecStatus;
(function (SpecStatus) {
    SpecStatus["PASSED"] = "passed";
    SpecStatus["FAILED"] = "failed";
    SpecStatus["BROKEN"] = "broken";
    SpecStatus["PENDING"] = "pending";
    SpecStatus["DISABLED"] = "disabled";
    SpecStatus["EXCLUDED"] = "excluded";
    SpecStatus["TODO"] = "todo";
})(SpecStatus || (SpecStatus = {}));
exports.dateStr = () => {
    const date = new Date(Date.now());
    return (date.getFullYear() +
        '-' +
        (date.getMonth() + 1) +
        '-' +
        date.getDate() +
        ' ' +
        date.getUTCHours() +
        ':' +
        date.getMinutes() +
        ':' +
        date.getSeconds() +
        '.' +
        date.getMilliseconds());
};
exports.dateStrShort = () => {
    const date = new Date(Date.now());
    return (date.getFullYear() +
        '-' +
        (date.getMonth() + 1) +
        '-' +
        date.getDate() +
        'T' +
        date.getUTCHours() +
        '-' +
        date.getMinutes() +
        '-' +
        date.getSeconds() +
        '.' +
        date.getMilliseconds());
};
class AllureReporter extends allure_js_commons_1.Allure {
    constructor(config) {
        super(new allure_js_commons_1.AllureRuntime(config !== null && config !== void 0 ? config : { resultsDir: 'allure-results' }));
        this.runningTest = null;
        this.runningGroup = null;
        this.groupNameStack = [];
        this.stepStack = [];
        this.currentStepStatus = null;
        this.featureForSuite = null;
        this.storyForSuite = null;
        this.featureForTest = null;
        this.storyForTest = null;
        this.environmentInfo = {};
    }
    get currentGroup() {
        if (this.runningGroup === null) {
            throw new Error('No active group');
        }
        return this.runningGroup;
    }
    get currentTest() {
        if (this.runningTest === null) {
            throw new Error('No active test');
        }
        return this.runningTest;
    }
    get currentExecutable() {
        var _a;
        return (_a = this.currentStep) !== null && _a !== void 0 ? _a : this.currentTest;
    }
    startGroup(name) {
        // todo check currentgroup.startgroup
        // todo check empty name
        this.runningGroup = this.runtime.startGroup(name);
        this.groupNameStack.push(name);
    }
    // todo decorators
    startTest(spec) {
        this.runningTest = this.currentGroup.startTest(spec.description);
        this.runningTest.fullName = spec.fullName;
        // Capture Jest worker thread for timeline report
        if (process.env.JEST_WORKER_ID) {
            this.currentTest.addLabel(allure_js_commons_1.LabelName.THREAD, `${('0' + Number(process.env.JEST_WORKER_ID)).slice(-2)}`);
        }
        this.applyGroupping();
    }
    startStep(name, start) {
        // todo configurable
        const allureStep = this.currentExecutable.startStep(exports.dateStr() + ' | ' + name, start);
        this.stepStack.push(allureStep);
        return allureStep;
    }
    stepStatus(status, details) {
        if (this.currentStep) {
            this.currentStepStatus = { status: status, details: details };
        }
    }
    getAttachFile(content, type) {
        return this.runtime.writeAttachment(stripAnsi(content), type);
    }
    endStep(status, stage, details, end) {
        const step = this.stepStack.pop();
        if (!step) {
            console.log('No step started');
            return;
        }
        step.stage = stage !== null && stage !== void 0 ? stage : allure_js_commons_1.Stage.FINISHED;
        if (status) {
            step.status = status;
        }
        if ((details === null || details === void 0 ? void 0 : details.message) || (details === null || details === void 0 ? void 0 : details.trace)) {
            step.statusDetails = {
                message: details.message,
                trace: details.trace,
            };
        }
        if (details) {
            // todo: status details does not work in report, workaround below
            const type = allure_js_commons_1.ContentType.JSON;
            const file = this.getAttachFile(details, type);
            step.addAttachment('StatusDetails_' + exports.dateStrShort(), type, file);
        }
        step.endStep(end);
        this.currentStepStatus = null;
    }
    endSteps() {
        while (this.currentStep !== null) {
            this.endStep(allure_js_commons_1.Status.BROKEN);
        }
    }
    applyGroupping() {
        const replaceDot = (name) => {
            // todo regexp with \s
            if (name.substr(0, 1) === '.') {
                return name.substr(1, name.length - 1);
            }
            if (name.substr(name.length - 1) === '.') {
                return name.substr(0, name.length - 1);
            }
            return name;
        };
        const groups = this.groupNameStack.map((p) => replaceDot(p));
        this.addPackage(groups.join('.'));
        if (groups.length > 0) {
            this.parentSuite(groups[0]);
        }
        if (groups.length > 1) {
            this.suite(groups[1]);
        }
        if (groups.length > 2) {
            this.subSuite(groups[2]);
        }
    }
    endTest(spec) {
        this.endSteps();
        if (spec.status === SpecStatus.PASSED) {
            this.currentTest.status = allure_js_commons_1.Status.PASSED;
            this.currentTest.stage = allure_js_commons_1.Stage.FINISHED;
        }
        if (spec.status === SpecStatus.BROKEN) {
            this.currentTest.status = allure_js_commons_1.Status.BROKEN;
            this.currentTest.stage = allure_js_commons_1.Stage.FINISHED;
        }
        if (spec.status === SpecStatus.FAILED) {
            this.currentTest.status = allure_js_commons_1.Status.FAILED;
            this.currentTest.stage = allure_js_commons_1.Stage.FINISHED;
        }
        if (spec.status === SpecStatus.PENDING ||
            spec.status === SpecStatus.DISABLED ||
            spec.status === SpecStatus.EXCLUDED ||
            spec.status === SpecStatus.TODO) {
            this.currentTest.status = allure_js_commons_1.Status.SKIPPED;
            this.currentTest.stage = allure_js_commons_1.Stage.PENDING;
            this.currentTest.detailsMessage = spec.pendingReason || 'Suite disabled';
        }
        // Capture exceptions
        const exceptionInfo = this.findMessageAboutThrow(spec.failedExpectations) ||
            this.findAnyError(spec.failedExpectations);
        if (exceptionInfo !== null && typeof exceptionInfo.message === 'string') {
            let { message } = exceptionInfo;
            message = stripAnsi(message);
            this.currentTest.detailsMessage = message;
            if (exceptionInfo.stack && typeof exceptionInfo.stack === 'string') {
                let { stack } = exceptionInfo;
                stack = stripAnsi(stack, 0);
                stack = stack.replace(message, '');
                this.currentTest.detailsTrace = stack;
            }
        }
        if (this.featureForSuite && this.featureForTest == null) {
            super.feature(this.featureForSuite);
        }
        this.featureForTest = null;
        // todo
        if (this.storyForSuite && this.storyForTest == null) {
            super.story(this.storyForSuite);
        }
        this.storyForTest = null;
        this.currentTest.endTest();
    }
    get currentStep() {
        if (this.stepStack.length > 0) {
            return this.stepStack[this.stepStack.length - 1];
        }
        return null;
    }
    writeCategories(categories) {
        super.writeCategoriesDefinitions(categories);
    }
    endGroup() {
        if (!this.currentGroup) {
            throw new Error('No runningGroup');
        }
        this.runtime.writeGroup({
            name: this.currentGroup.name,
            uuid: this.currentGroup.uuid,
            befores: [],
            afters: [],
            children: [],
        });
        this.groupNameStack.pop();
        this.currentGroup.endGroup();
    }
    findMessageAboutThrow(expectations) {
        for (const expectation of expectations || []) {
            if (expectation.matcherName === '') {
                return expectation;
            }
        }
        return null;
    }
    findAnyError(expectations) {
        expectations = expectations || [];
        if (expectations.length > 0) {
            return expectations[0];
        }
        return null;
    }
    step(name, body, start, ...args) {
        var _a, _b, _c;
        const allureStep = this.startStep(name, start);
        let result;
        if (!body) {
            this.endStep(allure_js_commons_1.Status.PASSED);
            return;
        }
        try {
            result = allureStep.wrap(body)(args);
        }
        catch (error) {
            this.endStep(allure_js_commons_1.Status.FAILED);
            throw error;
        }
        if (allure_js_commons_1.isPromise(result)) {
            const promise = result;
            return promise
                .then((a) => {
                var _a, _b, _c;
                this.endStep((_b = (_a = this.currentStepStatus) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : allure_js_commons_1.Status.PASSED, undefined, (_c = this.currentStepStatus) === null || _c === void 0 ? void 0 : _c.details);
                return a;
            })
                .catch((error) => {
                console.log('Result fail: isPromise');
                this.endStep(allure_js_commons_1.Status.FAILED);
                throw error;
            });
        }
        else {
            this.endStep((_b = (_a = this.currentStepStatus) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : allure_js_commons_1.Status.PASSED, undefined, (_c = this.currentStepStatus) === null || _c === void 0 ? void 0 : _c.details);
            return result;
        }
    }
    addEnvironment(name, value) {
        this.environmentInfo[name] = value;
        super.writeEnvironmentInfo(this.environmentInfo);
        return this;
    }
    writeAttachment(content, type) {
        return this.runtime.writeAttachment(content, type);
    }
    logStep(name, status, attachments) {
        // console.log('AllureImpl status:', status);
        /*const wrappedStep = this.startStep(name);
    
                    if (attachments) {
                        for (const {name, content, type} of attachments) {
                            this.attachment(name, content, type);
                        }
                    }
    
                    wrappedStep.logStep(status);
                    wrappedStep.endStep();*/
    }
    attachment(name, content, type) {
        const file = this.runtime.writeAttachment(typeof content === 'string' ? stripAnsi(content) : content, type);
        this.currentTest.addAttachment(name, type, file);
    }
    stepAttachement(name, content, type) {
        const file = this.runtime.writeAttachment(content, type);
        this.currentExecutable.addAttachment(name, type, file);
    }
    addPackage(value) {
        this.currentTest.addLabel(allure_js_commons_1.LabelName.PACKAGE, value);
        return this;
    }
    addParameter(name, value) {
        this.currentExecutable.addParameter(name, value);
        return this;
    }
    addParameters(...params) {
        params.forEach((p) => {
            const value = typeof p[1] !== 'string' ? JSON.stringify(p[1]) : p[1];
            this.currentExecutable.addParameter(p[0], value);
        });
        return this;
    }
    addTestPathParameter(relativeFrom, spec) {
        const relativePath = path_1.relative(relativeFrom, spec.testPath);
        this.addParameter('Test Path', relativePath);
        return this;
    }
    addLink(options) {
        var _a;
        this.currentTest.addLink(options.url, (_a = options.name) !== null && _a !== void 0 ? _a : options.url, options.type);
        return this;
    }
    addIssue(options) {
        var _a;
        // todo config
        /* options.url ??
            (this.config?.issueUri ? this.config.issueUri(options.id) : undefined);*/
        /*if (!url) {
          throw new Error('Specify url or issueUri in config');
        }*/
        const link = `${options.url}${options.id}`;
        this.issue((_a = options.name) !== null && _a !== void 0 ? _a : options.id, link);
        return this;
    }
    addTms(options) {
        var _a;
        // todo config
        // const uri = 'some';
        /* options.url ??
            (this.config?.tmsUri ? this.config.tmsUri(options.id) : undefined);*/
        /*if (!uri) {
          throw new Error('Specify url or tmsUri in config');
        }*/
        const link = `${options.url}${options.id}`;
        this.tms((_a = options.name) !== null && _a !== void 0 ? _a : options.id, link);
        return this;
    }
    addAttachment(name, buffer, type) {
        this.stepAttachement(name, buffer, type);
        return this;
    }
    addTestAttachment(name, buffer, type) {
        this.attachment(name, buffer, type);
        return this;
    }
    addLabel(name, value) {
        this.currentTest.addLabel(name, value);
        return this;
    }
    description(description) {
        this.currentTest.description = description;
        return this;
    }
    descriptionHtml(description) {
        this.currentTest.descriptionHtml = description;
        return this;
    }
    feature(feature) {
        if (this.runningTest !== null) {
            super.feature(feature);
            this.featureForTest = feature;
            return this;
        }
        if (this.featureForSuite) {
            throw new Error('Feature for suite can be set only once');
        }
        this.featureForSuite = feature;
        return this;
    }
    story(story) {
        if (this.runningTest !== null) {
            super.story(story);
            this.storyForTest = story;
            return this;
        }
        if (this.storyForSuite) {
            throw new Error('Story for suite can be set only once');
        }
        this.storyForSuite = story;
        return this;
    }
    tag(tag) {
        super.tag(tag);
    }
    owner(owner) {
        super.owner(owner);
    }
    lead(lead) {
        super.label(allure_js_commons_1.LabelName.LEAD, lead);
    }
    framework(framework) {
        super.label(allure_js_commons_1.LabelName.FRAMEWORK, framework);
    }
    language(language) {
        super.label(allure_js_commons_1.LabelName.LANGUAGE, language);
    }
    as_id(id) {
        super.label(allure_js_commons_1.LabelName.AS_ID, id);
    }
    host(host) {
        super.label(allure_js_commons_1.LabelName.HOST, host);
    }
    testClass(testClass) {
        super.label(allure_js_commons_1.LabelName.TEST_CLASS, testClass);
    }
    testMethod(testMethod) {
        super.label(allure_js_commons_1.LabelName.TEST_METHOD, testMethod);
    }
    severity(severity) {
        super.severity(severity);
    }
}
exports.AllureReporter = AllureReporter;
